/**
 * @fileoverview Firestore Security Rules for Expense Tracker App
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. Users can only create, read, update,
 * and delete data associated with their own user ID. All data is nested under /users/{userId},
 * creating a clear separation of data and preventing unauthorized access.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information (UserProfile entity).
 * - /users/{userId}/expenses/{expenseId}: Stores individual expense records (Expense entity).
 * - /users/{userId}/contributions/{contributionId}: Stores contribution records for shared expenses (Contribution entity).
 * - /users/{userId}/categories/{categoryId}: Stores user-defined expense categories (Category entity).
 * - /users/{userId}/paymentMethods/{paymentMethodId}: Stores user-defined payment methods (PaymentMethod entity).
 * - /users/{userId}/tags/{tagId}: Stores user-defined tags for expenses (Tag entity).
 *
 * Key Security Decisions:
 * - User Listing Denied: Listing all users is explicitly denied to protect user privacy.
 * - Ownership Enforcement: All write operations are validated against the authenticated user's UID.
 * - Data Consistency: On create, the rules enforce that the userId field within a subcollection document matches the {userId} in the path. This creates a strong, verifiable link between the user and their data. On update, the rules enforce that this link cannot be changed.
 * - No Schema Enforcement: The rules do not enforce the schema of the data being written, except for the critical userId field in subcollections.
 *
 * Denormalization for Authorization:
 *  - The 'userId' field is critically important for authorization of data stored in subcollections under `/users/{userId}`. To avoid needing to do `get()` operations, the `userId` field is added to each of the schemas.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure the UserProfile document.
     * @path /databases/{database}/documents/users/{userId}
     * @allow (create) User with matching UID can create their profile.
     * @allow (get) User with matching UID can read their profile.
     * @allow (update) User with matching UID can update their profile.
     * @allow (delete) User with matching UID can delete their profile.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @deny (get) User cannot read another user's profile.
     * @deny (update) User cannot update another user's profile.
     * @deny (delete) User cannot delete another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secure the Expenses subcollection.
     * @path /databases/{database}/documents/users/{userId}/expenses/{expenseId}
     * @allow (create) User can create an expense with a matching userId.
     * @allow (get) User can read their own expense.
     * @allow (list) User can list their own expenses.
     * @allow (update) User can update their own expense.
     * @allow (delete) User can delete their own expense.
     * @deny (create) User cannot create an expense with a mismatched userId.
     * @deny (get) User cannot read another user's expense.
     * @deny (list) User cannot list another user's expenses.
     * @deny (update) User cannot update another user's expense.
     * @deny (delete) User cannot delete another user's expense.
     * @principle Enforces document ownership and relational integrity for all operations.
     */
    match /users/{userId}/expenses/{expenseId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure the Contributions subcollection.
     * @path /databases/{database}/documents/users/{userId}/contributions/{contributionId}
     * @allow (create) User can create a contribution with a matching userId.
     * @allow (get) User can read their own contribution.
     * @allow (list) User can list their own contributions.
     * @allow (update) User can update their own contribution.
     * @allow (delete) User can delete their own contribution.
     * @deny (create) User cannot create a contribution with a mismatched userId.
     * @deny (get) User cannot read another user's contribution.
     * @deny (list) User cannot list another user's contributions.
     * @deny (update) User cannot update another user's contribution.
     * @deny (delete) User cannot delete another user's contribution.
     * @principle Enforces document ownership and relational integrity for all operations.
     */
    match /users/{userId}/contributions/{contributionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure the Categories subcollection.
     * @path /databases/{database}/documents/users/{userId}/categories/{categoryId}
     * @allow (create) User can create a category with a matching userId.
     * @allow (get) User can read their own category.
     * @allow (list) User can list their own categories.
     * @allow (update) User can update their own category.
     * @allow (delete) User can delete their own category.
     * @deny (create) User cannot create a category with a mismatched userId.
     * @deny (get) User cannot read another user's category.
     * @deny (list) User cannot list another user's categories.
     * @deny (update) User cannot update another user's category.
     * @deny (delete) User cannot delete another user's category.
     * @principle Enforces document ownership and relational integrity for all operations.
     */
    match /users/{userId}/categories/{categoryId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure the PaymentMethods subcollection.
     * @path /databases/{database}/documents/users/{userId}/paymentMethods/{paymentMethodId}
     * @allow (create) User can create a payment method with a matching userId.
     * @allow (get) User can read their own payment method.
     * @allow (list) User can list their own payment methods.
     * @allow (update) User can update their own payment method.
     * @allow (delete) User can delete their own payment method.
     * @deny (create) User cannot create a payment method with a mismatched userId.
     * @deny (get) User cannot read another user's payment method.
     * @deny (list) User cannot list another user's payment methods.
     * @deny (update) User cannot update another user's payment method.
     * @deny (delete) User cannot delete another user's payment method.
     * @principle Enforces document ownership and relational integrity for all operations.
     */
    match /users/{userId}/paymentMethods/{paymentMethodId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure the Tags subcollection.
     * @path /databases/{database}/documents/users/{userId}/tags/{tagId}
     * @allow (create) User can create a tag with a matching userId.
     * @allow (get) User can read their own tag.
     * @allow (list) User can list their own tags.
     * @allow (update) User can update their own tag.
     * @allow (delete) User can delete their own tag.
     * @deny (create) User cannot create a tag with a mismatched userId.
     * @deny (get) User cannot read another user's tag.
     * @deny (list) User cannot list another user's tags.
     * @deny (update) User cannot update another user's tag.
     * @deny (delete) User cannot delete another user's tag.
     * @principle Enforces document ownership and relational integrity for all operations.
     */
    match /users/{userId}/tags/{tagId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }
  }
}